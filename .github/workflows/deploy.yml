name: Deploy Rubiz Help AI

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  BRAND: rubiz
  NAMESPACE: rubiz
  # Uses flash-help-ai Docker image - no brand-specific build needed
  DOCKER_IMAGE: gcr.io/flashvpn-253908/flash-help-ai:575bd826

jobs:
  # Determine deployment environment
  determine-deployment:
    name: Determine Deployment Strategy
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.deployment-logic.outputs.should-deploy }}
      environment: ${{ steps.deployment-logic.outputs.environment }}
      require-approval: ${{ steps.deployment-logic.outputs.require-approval }}
    steps:
      - name: Determine deployment logic
        id: deployment-logic
        run: |
          # Only deploy to production for Rubiz
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"

          if [ "$BRANCH_NAME" = "main" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "require-approval=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "require-approval=false" >> $GITHUB_OUTPUT
          fi

  # Production Deployment Approval Gate
  production-approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: [determine-deployment]
    if: needs.determine-deployment.outputs.require-approval == 'true'
    environment:
      name: production
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Request deployment approval
        run: |
          echo "üöÄ Production deployment requested for Rubiz Help AI:"
          echo "‚Ä¢ Branch: ${{ github.ref_name }}"
          echo "‚Ä¢ Commit: ${{ github.sha }}"
          echo "‚Ä¢ Image: ${{ env.DOCKER_IMAGE }}"
          echo "‚Ä¢ Namespace: ${{ env.NAMESPACE }}"

  # Deploy to Kubernetes
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [determine-deployment, production-approval]
    if: |
      always() &&
      needs.determine-deployment.outputs.should-deploy == 'true' &&
      (needs.determine-deployment.outputs.require-approval == 'false' || needs.production-approval.result == 'success')
    environment:
      name: production
      url: https://home.rubiz.io/help-ai/health
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl for DigitalOcean
        run: |
          # List available clusters for debugging
          echo "Available DigitalOcean clusters:"
          doctl kubernetes cluster list || echo "Could not list clusters"

          # Only deploy to production cluster for Rubiz
          CLUSTER_NAME="${{ secrets.DO_CLUSTER_NAME_PROD || 'prod-jss' }}"

          echo "Configuring kubectl for production cluster: $CLUSTER_NAME"

          # Generate kubeconfig using doctl
          doctl kubernetes cluster kubeconfig save "$CLUSTER_NAME" --expiry-seconds 600

          # Verify the configuration
          echo "Verifying cluster connectivity..."
          kubectl cluster-info

          # Set the namespace
          kubectl config set-context --current --namespace=${{ env.NAMESPACE }}

          echo "Current context:"
          kubectl config current-context

          echo "Available namespaces:"
          kubectl get namespaces | grep -E "^(${{ env.NAMESPACE }}|default)" || true

      - name: Verify cluster connectivity
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Create or update secrets
        run: |
          # Create secrets for sensitive data only
          # Non-sensitive config is embedded directly in deployment.yaml
          kubectl create secret generic ${{ env.BRAND }}-help-ai-secrets \
            --from-literal=NOTION_TOKEN="${{ secrets.NOTION_TOKEN }}" \
            --from-literal=OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            --from-literal=NOTION_DATABASE_ID="${{ secrets.NOTION_DATABASE_ID }}" \
            --from-literal=CHATWOOT_API_ACCESS_TOKEN="${{ secrets.CHATWOOT_API_ACCESS_TOKEN || '' }}" \
            --from-literal=NOTION_WEBHOOK_SECRET="${{ secrets.NOTION_WEBHOOK_SECRET || '' }}" \
            --from-literal=CHATWOOT_ACCOUNT_ID="${{ secrets.CHATWOOT_ACCOUNT_ID || '' }}" \
            --from-literal=CHATWOOT_INBOX_ID="${{ secrets.CHATWOOT_INBOX_ID || '' }}" \
            --from-literal=CHATWOOT_API_BASE_URL="${{ secrets.CHATWOOT_API_BASE_URL || 'https://app.chatwoot.com' }}" \
            --from-literal=CHATWOOT_WEBHOOK_SECRET="${{ secrets.CHATWOOT_WEBHOOK_SECRET || '' }}" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Update image tag in deployment manifests
        run: |
          # Update the Docker image tag in deployment files
          echo "Updating image tag to: ${{ env.DOCKER_IMAGE }}"

          # Replace image tag in production deployment
          sed -i.bak "s|image: gcr.io/flashvpn-253908/flash-help-ai:.*|image: ${{ env.DOCKER_IMAGE }}|g" k8s/prod/deployment.yaml

          # Show the updated image line
          echo "Updated deployment file:"
          grep "image: gcr.io" k8s/prod/deployment.yaml || echo "Image not found in deployment"

      - name: Deploy to Rubiz namespace
        run: |
          # Deploy all resources to the Rubiz namespace (production only)
          echo "Deploying to production environment..."
          kubectl apply -f k8s/prod/ --namespace=${{ env.NAMESPACE }}

          # Verify IngressRoute was created
          echo ""
          echo "Verifying IngressRoute configuration..."
          kubectl get ingressroute ${{ env.BRAND }}-help-ai-ingress --namespace=${{ env.NAMESPACE }} || echo "‚ö†Ô∏è IngressRoute not found"
          kubectl get middleware ${{ env.BRAND }}-help-ai-stripprefix --namespace=${{ env.NAMESPACE }} || echo "‚ö†Ô∏è Middleware not found"

      - name: Wait for deployment rollout
        run: |
          # Check deployment status with timeout
          if ! kubectl rollout status deployment/${{ env.BRAND }}-help-ai --namespace=${{ env.NAMESPACE }} --timeout=300s; then
            echo "Deployment rollout failed or timed out. Checking pod status..."
            kubectl get pods --namespace=${{ env.NAMESPACE }} -l app=${{ env.BRAND }}-help-ai
            echo ""
            echo "Pod descriptions:"
            kubectl describe pods --namespace=${{ env.NAMESPACE }} -l app=${{ env.BRAND }}-help-ai
            echo ""
            echo "Pod logs (if any):"
            kubectl logs --namespace=${{ env.NAMESPACE }} -l app=${{ env.BRAND }}-help-ai --tail=50 || echo "No logs available"
            exit 1
          fi

      - name: Verify deployment health
        run: |
          kubectl get pods --namespace=${{ env.NAMESPACE }} -l app=${{ env.BRAND }}-help-ai
          kubectl get services --namespace=${{ env.NAMESPACE }} -l app=${{ env.BRAND }}-help-ai

          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod -l app=${{ env.BRAND }}-help-ai --namespace=${{ env.NAMESPACE }} --timeout=300s

      - name: Run smoke tests
        run: |
          # Get service endpoint
          SERVICE_IP=$(kubectl get service ${{ env.BRAND }}-help-ai --namespace=${{ env.NAMESPACE }} -o jsonpath='{.spec.clusterIP}')

          # Basic internal health check
          echo "Testing internal service endpoint..."
          kubectl run curl-test --image=curlimages/curl --rm -i --restart=Never --namespace=${{ env.NAMESPACE }} -- \
            curl -f http://$SERVICE_IP:3000/health || echo "‚ö†Ô∏è Internal health check endpoint not available"

          # Test public endpoint via IngressRoute
          echo ""
          echo "Testing public endpoint via IngressRoute..."
          if [[ "${{ needs.determine-deployment.outputs.environment }}" == "production" ]]; then
            PUBLIC_URL="https://home.rubiz.io/help-ai/health"
          else
            PUBLIC_URL="https://uat-home.rubiz.io/help-ai/health"
          fi

          echo "Testing: $PUBLIC_URL"
          sleep 5  # Wait for Traefik to pick up the new IngressRoute

          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$PUBLIC_URL" || echo "000")
          if [ "$RESPONSE" = "200" ]; then
            echo "‚úÖ Public endpoint is accessible (HTTP $RESPONSE)"
          else
            echo "‚ö†Ô∏è Public endpoint returned HTTP $RESPONSE"
            echo "This may be expected if IngressRoute takes time to propagate"
          fi

  # Rollback capability
  rollback:
    name: Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && github.ref == 'refs/heads/main'
    needs: [deploy]
    environment:
      name: production-rollback
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl for DigitalOcean
        run: |
          # For rollback, we're always in production
          CLUSTER_NAME="${{ secrets.DO_CLUSTER_NAME_PROD || 'prod-jss' }}"

          echo "Configuring kubectl for cluster: $CLUSTER_NAME"

          # Generate kubeconfig using doctl
          doctl kubernetes cluster kubeconfig save "$CLUSTER_NAME" --expiry-seconds 600

          # Set the namespace
          kubectl config set-context --current --namespace=${{ env.NAMESPACE }}

      - name: Rollback deployment
        run: |
          echo "Rolling back deployment in ${{ env.NAMESPACE }} namespace"
          kubectl rollout undo deployment/${{ env.BRAND }}-help-ai --namespace=${{ env.NAMESPACE }}
          kubectl rollout status deployment/${{ env.BRAND }}-help-ai --namespace=${{ env.NAMESPACE }} --timeout=300s

  # Notification
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [deploy, determine-deployment]
    if: always() && needs.determine-deployment.outputs.should-deploy == 'true'
    steps:
      - name: Notify deployment status
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ needs.deploy.result }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
        if: env.SLACK_WEBHOOK_URL != ''
